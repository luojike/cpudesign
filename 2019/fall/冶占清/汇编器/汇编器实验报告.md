# 汇编器实验报告

班级：智能1602

学号：201608010629

姓名：冶占清

## 实验目标

设计一个RISC-V基本整数指令汇编器，能够实现将汇编指令转化为二进制

## 实验要求

- 使用python编写汇编器代码
- 汇编器的输入是进行模拟的汇编指令
- 汇编器的输出是经过汇编后的二进制指令文件

## 实验内容

### 汇编器简介

> 汇编器是将汇编语言翻译为机器语言的程序。一般而言，汇编生成的是目标代码，需要经链接器生成可执行代码才可以执行

> 汇编语言是一种以处理器指令系统为基础的低级语言，采用助记符表达指令操作码，采用标识符表示指令操作数。作为一门语言，对应于高级语言的编译器，需要一个汇编器将汇编语言原文件汇编成机器可执行的代码

### RISC-V指令集介绍

**RV32I指令集包含了六种基本指令格式，分别是：**

R类型指令：用于寄存器到寄存器操作

I类型指令：用于短立即数和访存load操作

S类型指令：用于访存store操作

B类型指令：用于条件跳转操作

U类型指令：用于长立即数

J类型指令：用于无条件跳转

**RISC-V指令集编码格式**

![](./RV32I.PNG)

**RISC-V指令**

![](./RV32_1.PNG)

![](./RV32_2.PNG)

## 汇编器设计框架

整个汇编器的框架设计如下：
```cpp
/ <标号>: add x1, x2, x3
// <标号>:
// 10101010101101001

// 汇编程序文件 file.asm
// 一行一个汇编语句

// 初始化地址计数器 addr_counter = 0;
// while(file.asm没有到文件尾) {
  // 读入一行
  // while(读入的是纯标号且不是文件尾) { 继续读一行 }

  // 拆开行，得到标号（有可能没有），操作码或者伪指令助记符，操作数

  // if(有标号) { 记下标号和当前地址计数器的值，保存到符号表；
                  // 查看未决汇编语句是否需要这个标号，并解决
                }

  // if(操作码助记符) { 
        // 生成操作码编码;
        // 操作数 -> 寄存器编号或者立即数
        // if(操作数是标号) { 查找符号表，如果查到，计算得到偏移量；
                       // 如果没查到，记下当前汇编语句和地址
           }

        // 生成指令的二进制表示 }
  // else(伪指令助记符) { 根据伪指令含义执行相应转换 }

}
```

## 汇编器设计代码

```python
# -*- coding: UTF-8 -*-
from head import*

def R_type(op,rd,rs1,rs2):
    return "{0:032b}".format(op|(rd<<7)|(rs1<<15)|(rs2<<20))

def I_type(op,rd,rs1,imm):
    return "{0:032b}".format(op|(rd<<7)|(rs1<<15)|(imm<<20))

def S_type(op,rs1,rs2,imm):
    return "{0:032b}".format(op|(rs1<<15)|(rs2<<20)|((imm&0xfe0)<<20)|((imm&0x1f)<<7))

def U_type(op,rd,imm):
    return "{0:032b}".format(op|(rd<<7)|(imm<<12))

def SB_type(op,rs1,rs2,imm):
    return "{0:032b}".format(op|(rs1<<15)|(rs2<<20)|((imm&(1<<11))<<20)|((imm&0x3f0)<<21)|((imm&(1<<10))>>3)|((imm&0xf)<<8))

def UJA_type(op,rd,imm):
    return "{0:032b}".format(op|(rd<<7)|((imm&(1<<19))<<12)|((imm&0x3ff)<<21)|((imm&(1<<10))<<10)|((imm&0x7f800)<<1))

def UJAR_type(op,rd,rs1,imm):
    return "{0:032b}".format(op|(rd<<7)|(rs1<<15)|(imm<<20))

d = []
def getnum(s):
    d = [0 for i in range(3)]
    j=0
    for i in range(len(s)):
        if s[i]>='0' and s[i]<='9':
            d[j]=d[j]*10+int(s[i])
            if i+1<len(s) and (s[i+1]<'0' or s[i+1]>'9'):
                j=j+1
        i=i+1
    return d

def main():
    f=open('input.txt','r')
    list1=["ADD","SUB","XOR","OR","AND","SLL","SRL","SRA","SLT","SLTU"]
    list2=["ADDI","SLTI","SLTIU","XORI","JALR","ORI","ANDI","SLLI","SRLI","SRAI","LB","LH","LW","LBU","LHU"]
    list3=["SB","SH","SW"]
    list4=["LUI","AUIPC"]
    list5=["BEQ","BNE","BLT","BGE","BLTU","BGEU"]
    list6=["JAL"]
    while True:
        line=f.readline()
        if len(line)==0:
            f.close()
            break
        line=line.strip('\n')
        line=line.split()
        op=line[0]
        s=line[1]
        d=getnum(s)
        with open("output.txt","a") as t:
            if op in list1:
                t.write(R_type(opcode[op],d[0],d[1],d[2])+'\n')
            elif op in list2:
                t.write(I_type(opcode[op],d[0],d[1],d[2])+'\n')
            elif op in list3:
                t.write(S_type(opcode[op],d[0],d[1],d[2])+'\n')
            elif op in list4:
                t.write(U_type(opcode[op],d[0],d[1])+'\n')
            elif op in list5:
                t.write(SB_type(opcode[op],d[0],d[1],d[2])+'\n')
            elif op in list6:
                t.write(UJA_type(opcode[op],d[0],d[1])+'\n')

if __name__=="__main__":
    main()
```

## 测试

### 测试平台

|模块|配置|备注|
|:--:|:--:|:--:|
|CPU|Core i5-6700U||
|操作系统|Windows10 专业版||
|运行环境|python 3.6||

###测试结果

输入：
ADD r3,r1,r2
SUB r3,r1,r2
XOR r3,r1,r2
OR r3,r1,r2
AND r3,r1,r2
SLL r3,r1,r2
SRL r3,r1,r2
SRA r3,r1,r2
SLT r3,r1,r2
SLTU r3,r1,r2
LB r2,r1,10
LH r2,r1,10
LW r2,r1,10
LBU r2,r1,10
LHU r2,r1,10
ADDI r2,r1,10
SLTI r2,r1,10
SLTIU r2,r1,10
XORI r2,r1,10
ORI r2,r1,10
ADDI r2,r1,10
SLLI r2,r1,10
SRLI r2,r1,10
SRAI r2,r1,10
SB r1,r2,36
SH r1,r2,36
SW r1,r2,36
LUI r1,200
AUIPC r1,200
BEQ r1,r2,200
BNE r1,r2,200
BLT r1,r2,200
BGE r1,r2,200
BLTU r1,r2,200
BGEU r1,r2,200
JAL r1,100
JALR r2,r1,10
```

输出：
00000000001000001000000110110011
01000000001000001000000110110011
00000000001000001100000110110011
00000000001000001110000110110011
00000000001000001111000110110011
00000000001000001001000110110011
00000000001000001101000110110011
01000000001000001101000110110011
00000000001000001010000110110011
00000000001000001011000110110011
00000000101000001000000100000011
00000000101000001001000100000011
00000000101000001010000100000011
00000000101000001100000100000011
00000000101000001101000100000011
00000000101000001000000100010011
00000000101000001010000100010011
00000000101000001011000100010011
00000000101000001100000100010011
00000000101000001110000100010011
00000000101000001000000100010011
00000000101000001001000100010011
00000000101000001101000100010011
01000000101000001101000100010011
00000010001000001000001000100011
00000010001000001001001000100011
00000010001000001010001000100011
00000000000011001000000010110111
00000000000011001000000010010111
00011000001000001000100001100011
00011000001000001001100001100011
00011000001000001100100001100011
00011000001000001101100001100011
00011000001000001110100001100011
00011000001000001111100001100011
00001100100000000000000011101111
00000110010000001000000101100111
```
## 结果分析

从测试结果可以看出编写的汇编器代码确实能够将汇编代码编译成二进制结果，可以说明编写的汇编器代码正确，达到了实验的目的。
